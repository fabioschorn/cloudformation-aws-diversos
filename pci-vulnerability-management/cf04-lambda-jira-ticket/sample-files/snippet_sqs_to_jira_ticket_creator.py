import boto3
import json
import os
import requests

# Configuration
JIRA_BASE_URL = os.environ["JIRA_BASE_URL"]
PERSONAL_ACCESS_TOKEN = os.environ["PERSONAL_ACCESS_TOKEN"]
PROJECT_KEY = os.environ["PROJECT_KEY"]
ASSIGNEE_USERNAME = os.environ.get("ASSIGNEE_USERNAME", "username")

# AWS Clients
sqs = boto3.client("sqs")
SQS_QUEUE_URL = os.environ["SQS_QUEUE_URL"]

def create_jira_issue_with_pat(jira_base_url, personal_access_token, project_key,
                                summary, description, issue_type="Story",
                                priority="High", assignee_username=None, custom_fields=None):
    create_issue_url = f"{jira_base_url}/rest/api/2/issue"
    fields_data = {
        "project": {"key": project_key},
        "summary": summary,
        "priority": {"name": priority},
        "description": description,
        "issuetype": {"name": issue_type},
    }
    if assignee_username:
        fields_data["assignee"] = {"name": assignee_username}
    if custom_fields:
        fields_data.update(custom_fields)
    headers = {
        "Authorization": f"Bearer {personal_access_token}",
        "Accept": "application/json",
        "Content-Type": "application/json"
    }
    response = requests.post(create_issue_url, headers=headers, data=json.dumps({"fields": fields_data}), timeout=30)
    if response.status_code not in (200, 201):
        raise Exception(f"Failed to create Jira issue. Status: {response.status_code}, Response: {response.text}")
    return response.json()

def process_qid_and_create_ticket(qid_rows):
    if not qid_rows:
        return None
    first_row = qid_rows[0]
    summary = f"PCI Vulnerability - QID {first_row['qid']} - {first_row['title']}"
    description = (
        "{color:#DE350B}This story was created in Jira Server 9.12.x using a Bearer token (PAT).{color}\n\n"
        "{color:#DE350B}Just a test!!!{color}\n\n"
        f"*Severity*: {first_row['severity']}\n\n"
        f"*Threat*: {first_row['threat']}\n\n"
        f"*Impact*: {first_row['impact']}\n\n"
        f"*Solutions*: {first_row['solution']}\n\n"
        "*Team Responsible*: TEAM-Sec \n\n"
        "*Appliances in threat:*\n\n"
        "||IP||DNS||OS||\n"
    )
    appliances_info = ""
    for row in qid_rows:
        appliance_line = f"|{row['ip']}|{row['dns']}|{row['os']}|\n"
        if len(description) + len(appliances_info) + len(appliance_line) > 32000:
            appliances_info += "... (additional appliances omitted due to character limit)\n"
            break
        appliances_info += appliance_line
    description += appliances_info
    custom_fields_required = {
        "customfield_10699": "TEST-W33K",
        "customfield_10669": "PCI",
        "customfield_10666": {"id": "93669"}
    }
    return create_jira_issue_with_pat(
        jira_base_url=JIRA_BASE_URL,
        personal_access_token=PERSONAL_ACCESS_TOKEN,
        project_key=PROJECT_KEY,
        summary=summary,
        description=description,
        assignee_username=ASSIGNEE_USERNAME,
        custom_fields=custom_fields_required
    )

def lambda_handler(event, context):
    print("Polling all messages from SQS for QID grouping and ticket creation...")
    qid_groups = {}
    max_batches = 20  # Adjust to control how many SQS calls
    batch_count = 0
    while batch_count < max_batches:
        response = sqs.receive_message(
            QueueUrl=SQS_QUEUE_URL,
            MaxNumberOfMessages=10,
            WaitTimeSeconds=2,
            VisibilityTimeout=30
        )
        messages = response.get("Messages", [])
        if not messages:
            break
        for msg in messages:
            try:
                body = json.loads(msg["Body"])
                qid = str(body.get("qid"))
                qid_groups.setdefault(qid, []).append(body)
                sqs.delete_message(QueueUrl=SQS_QUEUE_URL, ReceiptHandle=msg["ReceiptHandle"])
            except Exception as e:
                print(f"Skipping message due to error: {e}")
        batch_count += 1

    created_keys = []
    for qid, rows in qid_groups.items():
        try:
            result = process_qid_and_create_ticket(rows)
            if result:
                created_keys.append(result['key'])
        except Exception as e:
            print(f"Error processing QID group {qid}: {e}")

    print(f"\nSummary:\nTotal tickets created: {len(created_keys)}")
    print(f"Ticket keys: {', '.join(created_keys)}")
    return {"status": "completed", "tickets_created": len(created_keys)}